# Guia de correÃ§Ã£o de sintaxe TypeScript e padrÃµes Baileys
# Copie para o Replit como referÃªncia rÃ¡pida

============================================================
1. try / catch bemâ€‘formado em TypeScript
------------------------------------------------------------
```ts
try {
  // cÃ³digo que pode falhar
  await doSomething()
} catch (err) {
  console.error('Falhou:', err as Error)
  // opcional:
  // throw err          // propaga
} finally {
  // limpa recursos
}
```
*Erros comuns*: esquecer `)` ou `{` antes do `catch`, ou colocar `catch`
fora do bloco que comeÃ§ou no `try`.

============================================================
2. Listener `connection.update` assÃ­ncrono
------------------------------------------------------------
```ts
import { Boom } from '@hapi/boom'
import { DisconnectReason } from '@whiskeysockets/baileys'

sock.ev.on('connection.update', async ({ connection, lastDisconnect, isNewLogin }) => {
  if (connection === 'open') {
    console.log('ðŸŸ¢ Conectado!')
  }

  if (connection === 'close') {
    const code = (lastDisconnect?.error as Boom | undefined)?.output?.statusCode
    console.warn('ðŸ”´ Fechou, code:', code)

    const shouldReconnect = code !== DisconnectReason.loggedOut
    if (shouldReconnect) {
      await delay(5000)
      initSocket()               // reinicia
    }
  }

  if (isNewLogin) {
    console.log('ðŸ”‘ Novo login detectado')
  }
})
```

============================================================
3. Promise com timeout + listener (QR Code)
------------------------------------------------------------
```ts
function getQrCode(): Promise<string> {
  return new Promise((resolve, reject) => {
    const timeout = setTimeout(() => reject(new Error('QR timeout')), 90000)

    sock.ev.on('connection.update', ({ qr }) => {
      if (qr) {
        clearTimeout(timeout)
        resolve(qr)
      }
    })
  })
}
```
*Usa `setTimeout` + `resolve` apenas quando evento adequado chegar.*

============================================================
4. PadrÃ£o de reconexÃ£o automÃ¡tica (codes 515/428/408)
------------------------------------------------------------
```ts
const transientErrors = [515, 428, 408, DisconnectReason.connectionClosed]

function handleDisconnect(code?: number) {
  if (!transientErrors.includes(code ?? 0)) {
    console.log('Logout definitivo; nÃ£o reconectar')
    return
  }
  console.log('Tentando reconectar em 5â€¯sâ€¦')
  setTimeout(initSocket, 5000)
}
```
Chame essa funÃ§Ã£o dentro do bloco `connection === 'close'`.

============================================================
5. Estrutura limpa de condiÃ§Ãµes no listener
------------------------------------------------------------
Use `switch` para cÃ³digos ou `if` aninhado sempre com chaves:

```ts
switch (connection) {
  case 'open':
    // ...
    break
  case 'connecting':
    // ...
    break
  case 'close':
    if (!lastDisconnect) break
    const code = (lastDisconnect.error as Boom).output.statusCode
    handleDisconnect(code)
    break
}
```

============================================================
Exemplo de bloco corrigido (linha ~306)
------------------------------------------------------------
```ts
// ANTES (erro: catch fora do bloco)
try {
  await uploadPreKeys()
}   // <- faltava }
catch (err) {
  console.error(err)
}

// DEPOIS
try {
  await uploadPreKeys()
} catch (err) {
  console.error(err)
}
```

============================================================
Tipos utilitÃ¡rios
------------------------------------------------------------
```ts
type WAConnectionUpdate = {
  connection?: 'open'|'close'|'connecting'
  lastDisconnect?: { error?: Boom }
  isNewLogin?: boolean
  qr?: string
}
```

Salve este arquivo como **typescript_whatsapp_fix.txt**.
